#pragma config(Motor,  motorB,          right,         tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Cory Crowley #10180322
//Akin Shonibare #10185253

//Code for IR sensor
#define I2C_ADDR  0x10      /* I2C addr 0x02 for V1, 0x10 for V2*/
#define REG_OFFSET    0x42  /* Offset for data registers */

//Assumed Background noise level
#define NOISE 10

//definitions
void lightFollow();
int BrightLight;

//USED BY IR SENSOR FUNCTION
bool waitForI2C(tSensors port)
{
	while (true)
	{
		switch (nI2CStatus[port])
		{
			case i2cStatusStopped:
			case i2cStatusNoError:
				// request is complete...
				return true;
			case i2cStatusPending:
			case i2cStatusStartTransfer:
				// bus is still busy
				break;
			case i2cStatusFailed:
			case i2cStatusBadConfig:
				// when there is an error
				return false;
		}
		wait1Msec(1);
	}
	return true;
}


//IR SENSOR TASK
task IR_Sense(){

	ubyte request[3];  // I2C request message
	ubyte reply[6];		// accelerometer returns 7 values
	int replyLen;			// length of reply array.
	tSensors port;			// port the sensor is attached to.

	// which port is the accelerator hooked up to?
	port = S4;

	// Ensure the sensor is configured correctly
	SensorType[port] = sensorI2CCustom;

	eraseDisplay();


	while (true) {
		// Read the data from the sensor
		// setup the request message....
		request[0] = 2;             // Message size is 2 bytes..
		request[1] = I2C_ADDR; // I2C Address of sensor(0x02)
		request[2] = REG_OFFSET;		// location of registers to read 0x42
		replyLen = 6;								// how many registers to read

		// send request message to sensor.
		sendI2CMsg(port, &request[0], replyLen);

		// wait for a reply on the sensor port.
		// also check for sensor error...
		if (!waitForI2C(port)) {
			displayBigTextLine(4, "Error 1.");
			wait1Msec(2000);
			stopAllTasks();
		}

		// read the reply from the sensor.
		readI2CReply(port, &reply[0], replyLen);

		// make sure the bus is clear...
		// check for error.
		if (!waitForI2C(port)){
			displayBigTextLine(4, "Error 2.");
			wait1Msec(2000);
			stopAllTasks();
		}

		//Waits, then updates BrightLight value
		wait1Msec(5);
		BrightLight = reply[0];
	}
}

//sound detection and display
task SoundDB()
{
	//Declare Variables
	int i;
	int soundLVL;
	SensorType[S1] = sensorSoundDBA;
	soundLVL = 0;

	displayInverseStringAt(5, 120, "Sound Level");//Display 'Sound Level' at top left of screen

	while(true){
		soundLVL = SensorValue[S1];

		if(soundLVL > 80) soundLVL = 80;//set max for Db reading
		//Draw Sound Bar
		for(i = 0; i < soundLVL; i++){
			fillRect(0,0,30,NOISE + i);
			sleep(1);
		}
		//Erase Sound Bar
		for(i = soundLVL; i > 0; i--){
			eraseRect(0,(NOISE + i)-1,30,NOISE + i);
			sleep(1);
		}

	}//end while true
}//end soundDB

//Displays distance to light source **Only when driving towards light**
task distanceDisplay(){
	SensorType[S2] = sensorEV3_Ultrasonic;
	float distance;

	while(true){
			distance = SensorValue(S2);
		//displays light distance
		if(BrightLight >= 4 && BrightLight <= 6){
			displayStringAt(70, 90, "Light Detected!");//Display
			displayStringAt(70, 60, "Light Dist: %.2f",distance);//Display
		}
		//Erases display
		else{
			displayStringAt(70, 90, "                         ");//Display
			displayStringAt(70, 60, "                         ");//Display
		}
		wait1Msec(100);
	}
}
//----------------------------------TASK MAIN-------------------------------
task main()
{
	//Starts sound task
	startTask(SoundDB);
	//Starts IR sensing task
	startTask(IR_Sense);
	//Start distance display task
	startTask(distanceDisplay);
	//start light following loop
	while(true){
	lightFollow();
	wait1Msec(10);
	}
}//end task main-------------------------------------------------------------


//Follow brightest light direction
void lightFollow(){
//Boleans for storing previous rotation direction
bool wasRotatingR, wasRotatingL;
//Displays brightest direction
displayStringAt(90, 120, "Light Dir = %d",BrightLight);//Display
//Display sound level label
displayStringAt(5, 120, "Sound Level");//Display

		//rotate Left
	if(BrightLight < 4 && BrightLight > 0){
			motor[right] = 10;
			motor[left] = -10;
			//Find direction of rotation
			wasRotatingR = false;
			wasRotatingL = true;
		}
		//Rotate Right
		else if(BrightLight > 6){

				motor[right] = -10;
				motor[left] = 10;
				//Find direction of rotation
				wasRotatingR = true;
				wasRotatingL = false;
		}
		//Drive forward while slightly turning right
		else if (BrightLight == 4){
			//If robot was rotating than stop, so robot doesn't pass light direction
			if(wasRotatingR || wasRotatingL){
			//stop motors
				motor[right] = 0;
				motor[left] = 0;
				wait1Msec(500);
		}
			//set right slightly faster than left for slow tilt
			motor[right] = 30;
			motor[left] = 28;
			wasRotatingR = false;
			wasRotatingL = false;
		}
		//Drive forward
		else if (BrightLight == 5){
			//If robot was rotating than stop, so robot doesn't pass light direction
			if(wasRotatingR || wasRotatingL){
				//stop motors
				motor[right] = 0;
				motor[left] = 0;
				wait1Msec(500);
		//play sound when directly following light
			setSoundVolume(20);
		//playSound
			playSound(soundFastUpwardTones);
		}
			motor[right] = 30;
			motor[left] = 30;
			//Set both rotation values to false: robot is driving forward
			wasRotatingR = false;
			wasRotatingL = false;
		}
		//Drive forward while slightly turning left
		else if (BrightLight == 6 ){
			//If robot was rotating than stop, so robot doesn't pass light direction
			if(wasRotatingR || wasRotatingL){
				motor[right] = 0;
				motor[left] = 0;
				wait1Msec(500);
		}
			motor[right] = 28;
			motor[left] = 30;
			//Set both rotation values to false: robot is driving forward
			wasRotatingR = false;
			wasRotatingL = false;
		}
		//When no brightest light direction is detected, continue rotating in last
		//rotation direction, or rotate left if robot wasn't previously rotating
		else{
			if(wasRotatingR){
				motor[right] = -10;
				motor[left] = 10;
			}
			else if(wasRotatingL){
				motor[right] = 10;
				motor[left] = -10;
			}
			else{
				motor[right] = 10;
				motor[left] = -10;
				wasRotatingL = true;
			}
		}//end else

}//end light follow
